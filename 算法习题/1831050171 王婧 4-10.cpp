//题目内容：
//设x1, x2, …, xn是实直线上的n个点。用固定长度的闭区间覆盖这n个点，至少需要多少个这样的固定长度闭区间 ? 设计求解此问题的有效算法。对于给定的实直线上的n个点和闭区间的长度k，编程计算覆盖点集的最少区间数。
//输入格式 :
//输入数据的第一行有2个正整数n和k，表示有n个点，且固定长度闭区间的长度为k。接下来的1行中，有n个整数，表示n个点在实直线上的坐标（可能相同）。
//
//贪心策略：
//闭区间从最左向右开始覆盖
//贪心选择：
//设闭区间集合为L = { l1,l2,…,lm }, 点序列集合为S = { S1,S2,…,Sn }。选择S1覆盖k个节点，剩下的问题转化为如何从L’ = L - {l1}中选取最少的区间去覆盖S’ = S - {S1, S2, …, Sk}
//最优子结构：
//问题最优解为L = { l1,l2,…,lm }，子问题的最优解为Ln - k = { l2,..,lm }, 则有Ln - kU{ l1 } = L
//算法：
//
//时间复杂度 : O(nlogn)
//空间复杂度 : O(n)
//
//输出格式：
//将编程计算出的最少区间数输出。
//输入样例：
//7 3
//1 2 3 4 5 - 2 6
//
//输出样例:
//3
//思路分析：首先这是一个一维线性问题，第一步要处理的就是将输入的点坐标进行排序、去重，然后从左往右一直覆盖即可。
//#include<iostream>
//#include<climits>
//#include<set>
//using namespace std;
//
//int main() 
//{
//    int n, k, t, result = 0;
//    set<int> s;
//    cin >> n >> k;
//
//    for (int index = 0; index < n; ++index) {
//        cin >> t;
//        s.insert(t);
//    }
//    t = INT_MIN;
//    
//    for (auto it = s.begin(); it != s.end(); ++it) {
//        if (t < *it) {
//            result += 1;
//            t = *it + k;
//        }
//    }
//    cout << result << endl;
//    return 0;
//}